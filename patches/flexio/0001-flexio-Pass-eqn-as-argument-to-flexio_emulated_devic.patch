From 5014feb8b683f95402cf64159bf2e85c1d9d053c Mon Sep 17 00:00:00 2001
From: Bodong Wang <bodong@nvidia.com>
Date: Tue, 27 Sep 2022 13:41:13 +0300
Subject: [PATCH] flexio: Pass eqn as argument to
 flexio_emulated_device_msix_create

Pass eqn as argument to flexio_emulated_device_msix_create to
create alias_eqn/cqn.
---
 libflexio/flexio.h     |  4 ++--
 libflexio/src/flexio.c | 33 ++++++++++++---------------------
 2 files changed, 14 insertions(+), 23 deletions(-)

diff --git a/libflexio/flexio.h b/libflexio/flexio.h
index 4e354f0..30f968a 100644
--- a/libflexio/flexio.h
+++ b/libflexio/flexio.h
@@ -824,8 +824,8 @@ flexio_status flexio_emulated_device_msix_create(struct flexio_process *process,
 						 struct ibv_context *target_ibv_ctx,
 						 uint8_t direct_mode, uint32_t target_uar_id,
 						 uint16_t msix_id,
-						 struct flexio_emu_device_msix_map* map,
-						 struct flexio_msix** msix);
+						 struct flexio_msix** msix,
+						 uint64_t eqn);
 
 /**
  * @brief destroy emulated device msix.
diff --git a/libflexio/src/flexio.c b/libflexio/src/flexio.c
index f8eee02..2d8fad4 100644
--- a/libflexio/src/flexio.c
+++ b/libflexio/src/flexio.c
@@ -173,6 +173,8 @@ static int allow_access_to_object(struct ibv_context *ctx, struct flexio_aliasab
 	for (i = 0; i < ALIAS_ACCESS_KEY_NUM_DWORD; i++)
 		attr.access_key_be[i] = htobe32(obj->access_key[i]);
 
+	flexio_err("attr->type 0x%x, attr->obj_id 0x%x\n", attr.type,
+		   attr.obj_id);
 	err = flexio_allow_other_vhca_access_prm_cmd(ctx, &attr);
 	if (err)
 		flexio_err("Failed to allow access to object");
@@ -1324,43 +1326,32 @@ flexio_status flexio_emulated_device_msix_create(struct flexio_process *process,
 						 struct ibv_context *target_ibv_ctx,
 						 uint8_t direct_mode, uint32_t target_uar_id,
 						 uint16_t msix_id,
-						 struct flexio_emu_device_msix_map* map,
-						 struct flexio_msix** msix)
+						 struct flexio_msix** msix,
+						 uint64_t eqn)
 {
 	struct flexio_aliasable_obj aliasable_eq = {0};
 	struct flexio_cq_attr sqcq_attr = {0};
 	flexio_uintptr_t cq_ring_daddr = 0;
 	flexio_uintptr_t cq_dbr_daddr = 0;
-	int i;
 
-	if (!process || !map || !target_ibv_ctx) {
-		flexio_err("illegal process/map/target_ibv_ctx argument: NULL\n");
+	if (!process || !target_ibv_ctx) {
+		flexio_err("illegal process/target_ibv_ctx argument: NULL\n");
 		goto err_create;
 	}
 
 	*msix = calloc(1, sizeof(struct flexio_msix));
 	assert(*msix);
 	(*msix)->msix_id = msix_id;
+	(*msix)->orig_eqn = eqn;
 
-	/* Find EQN */
-	for (i = 0; i < map->num_of_eqs; i++) {
-		if (map->eqn_to_msix_list[i].msix_vector == msix_id) {
-			(*msix)->orig_eqn = map->eqn_to_msix_list[i].eqn;
-			break;
-		}
-	}
-	if (i == map->num_of_eqs) {
-		flexio_err("msix id %u not found in msix map", msix_id);
+	aliasable_eq.id = (*msix)->orig_eqn;
+	aliasable_eq.type = 0x49;//MLX5_GENERAL_OBJECT_TYPES_EQ;
+	aliasable_eq.is_supported = 1;//process->hca_caps->eq_allowed_supported;
+	if (check_create_alias_eq(process, target_ibv_ctx, &aliasable_eq, &(*msix)->alias_eq)) {
+		flexio_err("********** alias_eq failure\n");
 		goto err_create;
 	}
 
-	/* alias eq */
-	aliasable_eq.id = (*msix)->orig_eqn;;
-	aliasable_eq.type = MLX5_GENERAL_OBJECT_TYPES_EQ;
-	aliasable_eq.is_supported = process->hca_caps->eq_allowed_supported;
-	if (check_create_alias_eq(process, target_ibv_ctx, &aliasable_eq, &(*msix)->alias_eq))
-		goto err_create;
-
 	if (direct_mode)
 		goto success_out;
 
-- 
2.34.1

